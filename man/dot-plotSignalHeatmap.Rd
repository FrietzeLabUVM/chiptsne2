% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions_plot_heatmap.R
\name{.plotSignalHeatmap}
\alias{.plotSignalHeatmap}
\title{plotSignalHeatmap}
\usage{
.plotSignalHeatmap(
  ct2,
  group_VARS = NULL,
  sort_VAR = NULL,
  balance_VAR = NULL,
  max_rows = 500,
  sort_strategy = c("hclust", "sort", "left", "right")[2],
  heatmap_colors = scale_fill_viridis_c(option = "magma"),
  heatmap_format_FUN = NULL,
  heatmap_theme = .heatmap_theme.no_y,
  annotation_colors = NULL,
  annotation_format_FUN = NULL,
  annotation_theme = .annotation_theme,
  annotation_text_size = 8,
  name_FUN = .prep_names,
  color_key_strategy = c("if_not_sorted", "except_sort_VAR", "all")[2],
  n_legend_rows = 1,
  relative_heatmap_width = 0.5,
  relative_heatmap_height = 0.66,
  return_data = FALSE
)
}
\arguments{
\item{ct2}{A ChIPtsne2 object}

\item{group_VARS}{Optional region metadata variables}

\item{sort_VAR}{Optional region metadata variable to use for sorting data.
Default to last entry in group_VARS.}

\item{sort_strategy}{Strategy to use for sorting within groups. Valid choices
are: 1) "sort", which sorts decreasing top to bottom, 2) "hclust" which
uses hierarchical clustering, 3) "left" which puts most left tiled profiles
at top, and 4) "right" which puts most right tilted profiles at top.}

\item{heatmap_colors}{Either a scale_fill_* or vector of R colors passed to
scale_fill_gradientn.}

\item{heatmap_format_FUN}{A function that applies any additional formatting
to the heatmap ggplot.}

\item{annotation_colors}{Colors to use for annotation, should be a character
vector or list of character vectors mirroring group_VARS for fine control.}

\item{annotation_format_FUN}{A function that applies any additional
formatting to the annotation ggplots. May be a single function to apply to
every annotation plot or list mirroring group_VARS for finer control.}

\item{annotation_text_size}{Font size for text appearing in clustered group annotations.}

\item{name_FUN}{A function to apply to facet labels (heatmap and annotation
columns). By default, underscores are replaced with newlines.}

\item{color_key_strategy}{Strategy to use for selection of annotation method.
The 2 annotation methods are arbitrary group annotation (has legend and no
labels) and clustered group annotation (no legend, labels on boxes).  All
members of a clustered group must be contiguous. Valid choices are: 1)
"if_not_sorted" applies clustered method whenever groups are sorted 2)
"except_sort_VAR" only uses clustered method for final instance of sort_VAR
3) "all" treats all as arbitrary groupings.}

\item{n_legend_rows}{How many rows to split the region legends into. Default
is 1.}

\item{relative_heatmap_width}{Fraction of final plot width dedicated to the heatmap.}

\item{relative_heatmap_height}{Fraction of final plot height dedicated to the heatmap.}

\item{return_data}{If TRUE, return the data.table instead of creating a plot.}
}
\value{
A grob of ggplots assembled using cowplot::plot_grid
}
\description{
plotSignalHeatmap
}
\examples{
ct2 = exampleChIPtsne2.with_meta()
ct2 = groupRegionsBySignalCluster(ct2, group_VAR = "cluster")
ct2 = groupRegionsByOverlap(ct2, seqsetvis::CTCF_in_10a_narrowPeak_grs[1:2], group_VAR = "overlap")
meta_df = getRegionMetaData(ct2)
meta_df = meta_df \%>\% dplyr::mutate(overlap_num = as.numeric(overlap))
ct2 = setRegionMetaData(ct2, meta_df)
plotSignalHeatmap(ct2, group_VARS = c("cluster", "overlap", "overlap_num"))
plotSignalHeatmap(ct2, group_VARS = c("overlap", "cluster"))
plotSignalHeatmap(
    ct2,
    group_VARS = c(
        "overlap",
        "peak_MCF10A_CTCF",
        "peak_MCF10AT1_CTCF",
        "peak_MCF10CA1_CTCF",
        "cluster",
        "overlap"
    ),
    color_key_strategy = "if_not_sorted"
)

plotSignalHeatmap(
    ct2,
    group_VARS = c(
        "cluster",
        "peak_MCF10A_CTCF",
        "peak_MCF10AT1_CTCF",
        "peak_MCF10CA1_CTCF",
        "overlap",
        "cluster",
        "cluster"
    ),
    color_key_strategy = "all"
)

plotSignalHeatmap(
    ct2,
    group_VARS = c(
        "cluster",
        "peak_MCF10A_CTCF",
        "peak_MCF10AT1_CTCF",
        "peak_MCF10CA1_CTCF",
        "overlap",
        "cluster",
        "cluster"
    ), n_legend_rows = 2, relative_heatmap_height = .5,
    color_key_strategy = "except_sort_VAR"
)

plotSignalHeatmap(ct2, group_VARS = c("overlap",
                                       "peak_MCF10A_CTCF",
                                       "peak_MCF10AT1_CTCF",
                                       "peak_MCF10CA1_CTCF",
                                       "cluster",
                                       "overlap"), sort_VAR = FALSE, n_legend_rows = 2)

plotSignalHeatmap(ct2, group_VARS = c("cluster", "overlap"))
plotSignalHeatmap(ct2, group_VARS = c("overlap", "cluster"))
plotSignalHeatmap(
    ct2,
    group_VARS = c(
        "overlap",
        "peak_MCF10A_CTCF",
        "peak_MCF10AT1_CTCF",
        "peak_MCF10CA1_CTCF",
        "cluster",
        "overlap"
    ),
    color_key_strategy = "if_not_sorted"
)

plotSignalHeatmap(
    ct2,
    group_VARS = c(
        "cluster",
        "peak_MCF10A_CTCF",
        "peak_MCF10AT1_CTCF",
        "peak_MCF10CA1_CTCF",
        "overlap",
        "cluster",
        "cluster"
    ),
    color_key_strategy = "all"
)

plotSignalHeatmap(
    ct2,
    group_VARS = c(
        "cluster",
        "peak_MCF10A_CTCF",
        "peak_MCF10AT1_CTCF",
        "peak_MCF10CA1_CTCF",
        "overlap",
        "cluster",
        "cluster"
    ),
    color_key_strategy = "except_sort_VAR"
)

plotSignalHeatmap(ct2, group_VARS = c("overlap",
                                       "peak_MCF10A_CTCF",
                                       "peak_MCF10AT1_CTCF",
                                       "peak_MCF10CA1_CTCF",
                                       "cluster",
                                       "overlap"), sort_VAR = FALSE, n_legend_rows = 2)
}
