% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions_normalize_signal.R
\name{normalizeSignalCapValue}
\alias{normalizeSignalCapValue}
\alias{normalizeSignalCapValue,ChIPtsne2_no_rowRanges-method}
\title{normalizeSignalCapValue}
\usage{
normalizeSignalCapValue(
  ct2,
  signal_cap_data = NULL,
  signal_cap_VAR = "cap_value",
  norm_to_1 = TRUE,
  trim_values_to_cap = TRUE,
  cap_floor = NULL
)

\S4method{normalizeSignalCapValue}{ChIPtsne2_no_rowRanges}(
  ct2,
  signal_cap_data = NULL,
  signal_cap_VAR = "cap_value",
  norm_to_1 = TRUE,
  trim_values_to_cap = TRUE,
  cap_floor = NULL
)
}
\arguments{
\item{ct2}{A ChIPtsne2_no_rowRanges object.}

\item{signal_cap_data}{An optional data.frame containing name_VAR in \code{ct2}
and \code{signal_cap_VAR}. Useful if you have calculated cap values outside of
ChIPtsne2 functions or are reapplying previously calculated values. Does
not require \link{calculateSignalCapValue} to be run.}

\item{signal_cap_VAR}{The attribute name in colData/sample metadata where cap
data results have been added. Should be added with
\link{calculateSignalCapValue}}

\item{norm_to_1}{If TRUE, all values will be divided by cap_VAR values.
Default is TRUE.}

\item{trim_values_to_cap}{If TRUE, all values will be capped at cap value
prior to dividing. Default is TRUE.}

\item{cap_floor}{Optional floor for cap values. Useful when input or control
samples are present that should not have true signal. Their calculated cap
values would be so low they'd only magnify background noise. Default of
NULL does nothing.}
}
\value{
A ChIPtsne2_no_rowRanges object. where value_VAR has been normalized according to
\code{signal_cap_VAR}
}
\description{
Applies a cap value for each sample. Meant to be run after
\link{calculateSignalCapValue} or after creating a data.frame to supply to
\code{signal_cap_data}.
}
\examples{
ct2 = exampleChIPtsne2.with_meta()
ct2 = calculateSignalCapValue(ct2, signal_cap_VAR = "higher_cap_value", cap_quantile = .98)
ct2.norm1 = normalizeSignalCapValue(
  ct2,
  signal_cap_VAR = "higher_cap_value"
)

# we can extract sample meta data and modify cap value
# then manually supply using the signal_cap_data parameter
cap_df = getSampleMetaData(ct2)
# by lowering the cap value we'll increase the final normalized values across the board.
cap_df$higher_cap_value = cap_df$higher_cap_value / 2
ct2.norm2 = normalizeSignalCapValue(
  ct2,
  signal_cap_VAR = "higher_cap_value",
  signal_cap_data = cap_df
)

# see the impact of each normalization
plotSignalLinePlot(ct2)
plotSignalLinePlot(ct2.norm1)
plotSignalLinePlot(ct2.norm2)
}
